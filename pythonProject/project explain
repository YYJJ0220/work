【project 1】SM4的基本实现和优化
   SM4是一种对称分组密码算法，每次操作128位数据块，密钥长度也为128位。SM4算法基于Feistel，有32轮加密和解密过程。
   主要包括密钥扩展、S盒替换、线性变换、轮密钥异或等步骤。
————SM4算法的基本实现
密钥扩展：生成轮密钥，共32个，用于每轮的加密或解密操作。
初始轮密钥异或：将输入的数据块与初始密钥异或。
32轮迭代：包括S盒替换、线性变换和轮密钥异或。
输出反序：最终的输出数据经过反序后得到密文或明文。

【project 2】实现图片水印嵌入和提取并进行鲁棒性测试
————鲁棒性测试
1.嵌入阶段
   把输入的彩色载体图从 BGR 转到 YCrCb，仅在亮度通道 Y 上做处理。
   接着将二值水印映射为比特序列，并按 8×8 块为单位逐块计算 DCT；在每一块的 (2,1) 中频位置，用加性规则把比特藏进去，α 默认 20。
嵌入后做逆 DCT 并重新拼回彩色图像，得到肉眼几乎察觉不到差异的.png。同时计算并打印 PSNR，用于衡量视觉不可感知性。
2.攻击阶段
   对含水印图施加 6 种几何攻击：水平翻转、垂直翻转、双向翻转、向右平移 20 px、向下平移 20 px、以及斜向平移 (15,15)。
   每种攻击后的结果图都保存到 results 目录，方便人工查看。
3.提取与鲁棒性评估
   攻击后的图片无需原始载体即可「盲提取」：同样按 8×8 块 DCT，直接根据 (2,1) 系数的符号还原比特。
   提取出的二值水印与原始水印做归一化互相关（NCC），数值越接近 1 表示鲁棒性越好。
   最终把 6 个 NCC 值绘制成柱状图，直观展示不同攻击对水印的影响。

【project 4】SM3的基本实现和相关长度扩展攻a击
   SM3 是一种基于Merkle-Damgard的加密函数，采用 256 位的输出哈希值，消息块大小为 512 位。
————SM3的基本实现
1.消息填充：将输入消息填充到接近块大小的倍数（512 位）的长度。
2.初始化参数：初始化八个 32 位初始值（IV）。
3.消息扩展：将每个 512 位的消息分组扩展为 132 个 32 位字。
4.压缩函数：使用布尔函数、非线性函数和循环移位等操作对每一个消息分组进行压缩。
5.输出哈希值：最终将所有块的压缩结果拼接起来，生成一个 256 位的哈希值。

————SM3长度扩展攻击
   在已知message与MAC的前提下，不需要已知key，只要知道key的长度，即可通过在message后添加信息计算来求得相应的MAC。
   因此，如果攻击者掌握了Hash(message)的值与message的长度，就可以在不知道message的情况下得到Hash(message||padding||message1)的值。
   代码说明如下：
1.随机生成一个消息m
2.对m进行SM3加密得到Hash
3.随机生成一个附加消息m_appenda
4.利用加密结束后的iv值作为初始向量，来加密m_append，得到hash猜测值
5.将消息进行填充并添加附加消息后再次进行加密得到hash计算值
6.比较hash猜测值与hash计算值，若相等，则攻击成功。

————Merkle Tree
   Merkle Tree是一种哈希树，用于编码大块的信息。 其中每个叶子节点都标有数据块的加密哈希值，而每个非叶子节点都标有其子节点的加密哈希值的标签。
   Merkle Tree的特别之处在于，这是一种自下而上建立的树，允许你验证某些值是否存在于树中，而不需要在树的每个元素上循环，这一特点非常有用。


【project 5】SM2的基本实现和优化
————SM2加密如下：
1.用随机数发生器产生随机数k (1<k<n-1)<br>
2.计算椭圆曲线点C1=[k]G=(x1,y1)，并将其转换为比特串（A的私钥生成公钥）<br>
3.计算椭圆曲线点S=[h]Pb，若S是无穷远点，则报错并退出 h为n的余因子<br>
4.计算椭圆曲线点[k]Pb=(x2,y2)，并将其转换为比特串（A的私钥乘B的公钥）<br>
5.计算t=KDF(x2||y2,klen)，若t为全0比特串，则返回①; KDF为密钥派生函数<br>
6.计算C2=M⊕t<br>
7.计算C3=Hash(x2||M||y2)<br>
8.输出密文C=C1||C3||C2<br>
————SM2解密如下：
1.从C中取出比特串C1，将其转换为椭圆曲线上的点，验证C1是否满足椭圆曲线方程<br>
2.计算椭圆曲线点S=[h]Pb，若S是无穷远点，则报错并退出<br>
3.计算[db]C1=(x2,y2)，并将其转换为比特串 db B的公钥<br>
4.计算t=KDF(x2||y2,klen)，若t为全0比特串，则返回（一） KDF为密钥派生函数<br>
5.从C中取出比特串C2,计算M=C2⊕t<br>
6.计算u=Hash(x2||M||y2)，从C中取出比特串C3，若u不等于C3，则报错并退出<br>
7.输出明文M<br>
